#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
二进制文件合并工具
用于将多个二进制文件（FSBL、比特流、U-Boot等）合并成单个boot.bin文件
支持Zynq和Versal平台
"""

import os
import sys
import argparse
import subprocess
import tempfile
from pathlib import Path
from typing import List, Dict, Optional, Tuple
import struct


class BinMerger:
    """二进制文件合并器"""

    def __init__(self, output_file: str = "boot.bin", platform: str = "zynq"):
        """
        Args:
            output_file: 输出文件路径
            platform: 平台类型 ('zynq', 'versal', 'microblaze')
        """
        self.output_file = Path(output_file)
        self.platform = platform
        self.components: List[Dict] = []

    def add_component(self, file_path: str, offset: str = "0x00000000",
                      component_type: str = "data", name: str = ""):
        """添加组件文件

        Args:
            file_path: 文件路径
            offset: 偏移地址（十六进制字符串）
            component_type: 组件类型 ('fsbl', 'bitstream', 'uboot', 'atf', 'data')
            name: 组件名称（可选）
        """
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"文件不存在: {file_path}")

        # 解析偏移地址
        if offset.startswith('0x'):
            offset_int = int(offset, 16)
        else:
            offset_int = int(offset)

        self.components.append({
            'path': file_path,
            'offset': offset_int,
            'type': component_type,
            'name': name or file_path.name,
            'size': file_path.stat().st_size
        })

    def merge_simple(self):
        """简单合并：按偏移地址将文件内容写入输出文件"""
        # 找到最大偏移和文件大小
        max_offset = 0
        max_end = 0
        for comp in self.components:
            end = comp['offset'] + comp['size']
            if end > max_end:
                max_end = end

        # 创建输出文件
        with open(self.output_file, 'wb') as f:
            # 写入每个组件
            for comp in self.components:
                f.seek(comp['offset'])
                with open(comp['path'], 'rb') as src:
                    f.write(src.read())
                print(f"写入 {comp['name']} 到偏移 0x{comp['offset']:08x}")

        print(f"合并完成: {self.output_file} (大小: {max_end} 字节)")

    def generate_bif(self, bif_path: Path) -> str:
        """生成BIF（Boot Image Format）文件内容

        Args:
            bif_path: BIF文件路径

        Returns:
            BIF文件内容
        """
        lines = [
            "// Boot Image Generation File",
            "// Generated by FPGABuilder merge_bin.py",
            f"// Platform: {self.platform}",
            "",
            "{"
        ]

        for comp in self.components:
            comp_type = comp['type']
            file_path = comp['path'].resolve()
            offset = comp['offset']

            if comp_type == 'fsbl':
                lines.append(f"    [bootloader] {{{file_path}}}")
                lines.append("    {")
                lines.append(f"        load = 0x{offset:08x};")
                lines.append("    }")
            elif comp_type == 'bitstream':
                lines.append(f"    {{{file_path}}}")
                lines.append("    {")
                lines.append(f"        load = 0x{offset:08x};")
                lines.append("    }")
            else:
                # 其他类型（uboot, atf, data等）
                lines.append(f"    {{{file_path}}}")
                lines.append("    {")
                lines.append(f"        load = 0x{offset:08x};")
                lines.append("    }")

            lines.append("")

        lines.append("}")

        bif_content = "\n".join(lines)
        with open(bif_path, 'w', encoding='utf-8') as f:
            f.write(bif_content)

        return bif_content

    def merge_with_bootgen(self, bootgen_path: Optional[str] = None):
        """使用Xilinx bootgen工具合并文件

        Args:
            bootgen_path: bootgen可执行文件路径（可选）
        """
        # 创建临时BIF文件
        with tempfile.NamedTemporaryFile(mode='w', suffix='.bif', delete=False, encoding='utf-8') as f:
            bif_path = Path(f.name)
            bif_content = self.generate_bif(bif_path)
            print(f"生成的BIF文件:\n{bif_content}")

        try:
            # 查找bootgen
            if bootgen_path:
                bootgen_cmd = bootgen_path
            else:
                # 尝试自动查找bootgen
                bootgen_cmd = self._find_bootgen()

            # 构建bootgen命令
            cmd = [
                bootgen_cmd,
                '-image', str(bif_path),
                '-arch', self.platform,
                '-o', str(self.output_file),
                '-w'  # 覆盖已存在的文件
            ]

            print(f"执行命令: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8')

            if result.returncode == 0:
                print(f"成功生成boot.bin: {self.output_file}")
                if result.stdout:
                    print(f"bootgen输出: {result.stdout}")
            else:
                print(f"bootgen失败，返回码: {result.returncode}")
                if result.stderr:
                    print(f"错误信息: {result.stderr}")
                # 尝试简单合并作为备选方案
                print("尝试简单合并...")
                self.merge_simple()

        finally:
            # 清理临时文件
            try:
                bif_path.unlink()
            except:
                pass

    def _find_bootgen(self) -> str:
        """查找bootgen可执行文件"""
        # 常见路径
        common_paths = [
            'bootgen',
            'bootgen.exe',
            r'C:\Xilinx\Vivado\*\bin\bootgen.exe',
            r'C:\Xilinx\Vitis\*\bin\bootgen.exe',
            '/opt/Xilinx/Vivado/*/bin/bootgen',
            '/opt/Xilinx/Vitis/*/bin/bootgen',
        ]

        import glob
        for path_pattern in common_paths:
            if '*' in path_pattern:
                matches = glob.glob(path_pattern)
                if matches:
                    return matches[0]
            else:
                if os.path.exists(path_pattern):
                    return path_pattern

        # 检查PATH环境变量
        import shutil
        bootgen = shutil.which('bootgen')
        if bootgen:
            return bootgen

        raise FileNotFoundError(
            "未找到bootgen工具。请确保Xilinx工具链在PATH中，"
            "或使用--bootgen-path指定bootgen路径。"
        )

    def validate_offsets(self) -> bool:
        """验证偏移地址是否重叠"""
        self.components.sort(key=lambda x: x['offset'])

        for i in range(len(self.components) - 1):
            curr = self.components[i]
            next_comp = self.components[i + 1]

            curr_end = curr['offset'] + curr['size']
            if curr_end > next_comp['offset']:
                print(f"错误: 文件重叠检测到:")
                print(f"  {curr['name']} (偏移: 0x{curr['offset']:08x}, 大小: {curr['size']})")
                print(f"  {next_comp['name']} (偏移: 0x{next_comp['offset']:08x})")
                return False

        return True


def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(
        description='合并多个二进制文件为boot.bin',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  %(prog)s -o boot.bin --fsbl fsbl.elf --bitstream system.bit --uboot u-boot.elf
  %(prog)s -o boot.bin --component fsbl.elf:0x00000000:fsbl --component system.bit:0x00100000
        """
    )

    parser.add_argument('-o', '--output', default='boot.bin',
                       help='输出文件路径 (默认: boot.bin)')
    parser.add_argument('--platform', choices=['zynq', 'versal', 'microblaze'],
                       default='zynq', help='目标平台 (默认: zynq)')
    parser.add_argument('--bootgen-path', help='bootgen工具路径 (可选)')
    parser.add_argument('--simple-merge', action='store_true',
                       help='使用简单合并而非bootgen')

    # 常用组件的快捷选项
    parser.add_argument('--fsbl', help='FSBL文件路径')
    parser.add_argument('--fsbl-offset', default='0x00000000',
                       help='FSBL偏移地址 (默认: 0x00000000)')
    parser.add_argument('--bitstream', help='比特流文件路径')
    parser.add_argument('--bitstream-offset', default='0x00100000',
                       help='比特流偏移地址 (默认: 0x00100000)')
    parser.add_argument('--uboot', help='U-Boot文件路径')
    parser.add_argument('--uboot-offset', default='0x00200000',
                       help='U-Boot偏移地址 (默认: 0x00200000)')
    parser.add_argument('--atf', help='ATF文件路径')
    parser.add_argument('--atf-offset', default='0x00300000',
                       help='ATF偏移地址 (默认: 0x00300000)')

    # 通用组件选项
    parser.add_argument('--component', action='append',
                       help='添加组件，格式: 文件路径:偏移地址:类型:名称')

    return parser.parse_args()


def main():
    """主函数"""
    args = parse_arguments()

    try:
        merger = BinMerger(args.output, args.platform)

        # 添加快捷选项指定的组件
        if args.fsbl:
            merger.add_component(args.fsbl, args.fsbl_offset, 'fsbl', 'FSBL')
        if args.bitstream:
            merger.add_component(args.bitstream, args.bitstream_offset, 'bitstream', 'Bitstream')
        if args.uboot:
            merger.add_component(args.uboot, args.uboot_offset, 'uboot', 'U-Boot')
        if args.atf:
            merger.add_component(args.atf, args.atf_offset, 'atf', 'ATF')

        # 添加通用组件
        if args.component:
            for comp_str in args.component:
                parts = comp_str.split(':')
                if len(parts) < 2:
                    print(f"错误: 组件格式无效: {comp_str}")
                    print("格式应为: 文件路径:偏移地址[:类型[:名称]]")
                    sys.exit(1)

                file_path = parts[0]
                offset = parts[1]
                comp_type = parts[2] if len(parts) > 2 else 'data'
                name = parts[3] if len(parts) > 3 else Path(file_path).name

                merger.add_component(file_path, offset, comp_type, name)

        # 检查是否有组件
        if not merger.components:
            print("错误: 未指定任何组件文件")
            sys.exit(1)

        # 验证偏移地址
        if not merger.validate_offsets():
            print("错误: 文件偏移地址重叠")
            sys.exit(1)

        # 显示组件信息
        print("组件列表:")
        for comp in merger.components:
            print(f"  {comp['name']}:")
            print(f"    路径: {comp['path']}")
            print(f"    偏移: 0x{comp['offset']:08x}")
            print(f"    大小: {comp['size']} 字节")
            print(f"    类型: {comp['type']}")
        print()

        # 执行合并
        if args.simple_merge:
            print("使用简单合并模式...")
            merger.merge_simple()
        else:
            print("使用bootgen工具合并...")
            merger.merge_with_bootgen(args.bootgen_path)

        print(f"\n合并完成: {args.output}")

    except Exception as e:
        print(f"错误: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()