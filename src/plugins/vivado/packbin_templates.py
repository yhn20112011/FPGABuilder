#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
二进制文件合并模板
用于生成boot.bin等二进制文件的合并脚本
"""

from typing import Dict, List, Any, Optional
from pathlib import Path
import os


class PackBinTemplate:
    """二进制文件合并模板"""

    def __init__(self, config: Dict[str, Any], bin_files_config: Optional[Dict[str, Any]] = None):
        """
        Args:
            config: 项目配置
            bin_files_config: 二进制文件配置，可选
        """
        self.config = config
        self.bin_files_config = bin_files_config or {}
        self.project_name = config.get('project', {}).get('name', 'fpga_project')
        self.project_dir = config.get('project_dir', './build')

        # 从配置中获取二进制文件设置
        self.fsbl_path = self.bin_files_config.get('fsbl_path', '')
        self.bitstream_path = self.bin_files_config.get('bitstream_path', '')
        self.uboot_path = self.bin_files_config.get('uboot_path', '')
        self.atf_path = self.bin_files_config.get('atf_path', '')
        self.output_path = self.bin_files_config.get('output_path', f'{self.project_dir}/boot.bin')
        self.fsbl_offset = self.bin_files_config.get('fsbl_offset', '0x00000000')
        self.bitstream_offset = self.bin_files_config.get('bitstream_offset', '0x00100000')
        self.uboot_offset = self.bin_files_config.get('uboot_offset', '0x00200000')
        self.atf_offset = self.bin_files_config.get('atf_offset', '0x00300000')

    def render(self) -> str:
        """渲染二进制合并模板"""
        lines = [
            '# 二进制文件合并脚本 - 由FPGABuilder生成',
            f'# 项目: {self.project_name}',
            ''
        ]

        # 检查必要的文件
        lines.append('# 检查输入文件')

        if self.fsbl_path:
            lines.append(f'if {{![file exists {{{self.fsbl_path}}}]}} {{')
            lines.append(f'    puts "警告: FSBL文件不存在: {self.fsbl_path}"')
            lines.append('}')

        if self.bitstream_path:
            lines.append(f'if {{![file exists {{{self.bitstream_path}}}]}} {{')
            lines.append(f'    puts "警告: 比特流文件不存在: {self.bitstream_path}"')
            lines.append('}')

        if self.uboot_path:
            lines.append(f'if {{![file exists {{{self.uboot_path}}}]}} {{')
            lines.append(f'    puts "警告: U-Boot文件不存在: {self.uboot_path}"')
            lines.append('}')

        if self.atf_path:
            lines.append(f'if {{![file exists {{{self.atf_path}}}]}} {{')
            lines.append(f'    puts "警告: ATF文件不存在: {self.atf_path}"')
            lines.append('}')

        lines.append('')

        # 使用bootgen生成boot.bin
        lines.append('# 使用bootgen生成boot.bin')
        lines.append(f'set output_file {{{self.output_path}}}')
        lines.append('set bootgen_script [file join [file dirname $output_file] "bootgen.bif"]')
        lines.append('')

        # 生成BIF文件内容
        lines.append('# 生成BIF文件')
        lines.append('set bif_content ""')
        lines.append('append bif_content "\\n// Boot Image Generation File"')
        lines.append('append bif_content "\\n// Generated by FPGABuilder"')
        lines.append('append bif_content "\\n\\n{"')
        lines.append('')

        # 添加各个镜像
        if self.fsbl_path:
            lines.append(f'# FSBL (First Stage Boot Loader)')
            lines.append(f'append bif_content "\\n    [bootloader] {{{self.fsbl_path}}}"')
            lines.append(f'append bif_content "\\n    {{')
            lines.append(f'        load = {self.fsbl_offset};')
            lines.append(f'    }}"')
            lines.append('')

        if self.bitstream_path:
            lines.append(f'# 比特流文件')
            lines.append(f'append bif_content "\\n    {{{self.bitstream_path}}}"')
            lines.append(f'append bif_content "\\n    {{')
            lines.append(f'        load = {self.bitstream_offset};')
            lines.append(f'    }}"')
            lines.append('')

        if self.uboot_path:
            lines.append(f'# U-Boot')
            lines.append(f'append bif_content "\\n    {{{self.uboot_path}}}"')
            lines.append(f'append bif_content "\\n    {{')
            lines.append(f'        load = {self.uboot_offset};')
            lines.append(f'    }}"')
            lines.append('')

        if self.atf_path:
            lines.append(f'# ATF (ARM Trusted Firmware)')
            lines.append(f'append bif_content "\\n    {{{self.atf_path}}}"')
            lines.append(f'append bif_content "\\n    {{')
            lines.append(f'        load = {self.atf_offset};')
            lines.append(f'    }}"')
            lines.append('')

        lines.append('append bif_content "\\n}"')
        lines.append('')

        # 写入BIF文件
        lines.append('# 写入BIF文件')
        lines.append('set fp [open $bootgen_script w]')
        lines.append('puts $fp $bif_content')
        lines.append('close $fp')
        lines.append('puts "BIF文件已生成: $bootgen_script"')
        lines.append('')

        # 运行bootgen
        lines.append('# 运行bootgen生成boot.bin')
        lines.append('if {[catch {')
        lines.append('    exec bootgen -image $bootgen_script -arch zynq -o $output_file -w')
        lines.append('    puts "boot.bin已生成: $output_file"')
        lines.append('} error_msg]} {')
        lines.append('    puts "错误: 生成boot.bin失败"')
        lines.append('    puts $error_msg')
        lines.append('    # 尝试使用Vivado内置的bootgen')
        lines.append('    if {[catch {')
        lines.append('        exec vivado -mode batch -source $bootgen_script -tclargs $output_file')
        lines.append('        puts "使用Vivado生成boot.bin: $output_file"')
        lines.append('    } error_msg2]} {')
        lines.append('        puts "所有bootgen尝试都失败:"')
        lines.append('        puts $error_msg2')
        lines.append('    }')
        lines.append('}')
        lines.append('')

        # 清理临时文件
        lines.append('# 清理临时文件')
        lines.append('if {[file exists $bootgen_script]} {')
        lines.append('    file delete -force $bootgen_script')
        lines.append('    puts "已清理临时BIF文件"')
        lines.append('}')
        lines.append('')

        lines.append('puts "二进制文件合并完成"')
        return '\n'.join(lines)


class MCSGenerationTemplate:
    """MCS文件生成模板（用于Flash编程）"""

    def __init__(self, config: Dict[str, Any], flash_config: Optional[Dict[str, Any]] = None):
        self.config = config
        self.flash_config = flash_config or {}
        self.project_name = config.get('project', {}).get('name', 'fpga_project')
        self.bitstream_path = self.flash_config.get('bitstream_path', '')
        self.output_path = self.flash_config.get('output_path', f'{self.project_name}.mcs')
        self.flash_size = self.flash_config.get('flash_size', '128')
        self.interface = self.flash_config.get('interface', 'SPIx4')
        self.load_bitstream = self.flash_config.get('load_bitstream', True)

    def render(self) -> str:
        """渲染MCS生成模板"""
        lines = [
            '# MCS文件生成脚本 - 用于Flash编程',
            f'# 项目: {self.project_name}',
            ''
        ]

        # 检查比特流文件
        if self.bitstream_path:
            lines.append(f'# 检查比特流文件')
            lines.append(f'if {{![file exists {{{self.bitstream_path}}}]}} {{')
            lines.append(f'    error "比特流文件不存在: {self.bitstream_path}"')
            lines.append('}')
            lines.append('')
        else:
            # 尝试自动查找比特流文件
            lines.append(f'# 自动查找比特流文件')
            lines.append('set bitstream_files [glob -nocomplain *.bit]')
            lines.append('if {[llength $bitstream_files] == 0} {')
            lines.append('    set bitstream_files [glob -nocomplain **/*.bit]')
            lines.append('}')
            lines.append('if {[llength $bitstream_files] == 0} {')
            lines.append('    error "未找到比特流文件"')
            lines.append('}')
            lines.append('set bitstream_path [lindex $bitstream_files 0]')
            lines.append(f'puts "使用比特流文件: $bitstream_path"')
            lines.append('')

        # 生成MCS文件
        lines.append('# 生成MCS文件')
        lines.append(f'set output_file {{{self.output_path}}}')
        lines.append(f'set flash_size {{{self.flash_size}}}')
        lines.append(f'set interface {{{self.interface}}}')
        lines.append('')

        lines.append('if {[catch {')
        lines.append('    # 写入比特流到MCS文件')
        lines.append('    write_cfgmem -force \\')
        lines.append(f'        -format mcs \\')
        lines.append(f'        -interface $interface \\')
        lines.append(f'        -loadbit "up 0x0 $bitstream_path" \\')
        lines.append(f'        -size $flash_size \\')
        lines.append(f'        $output_file')
        lines.append('    ')
        lines.append('    puts "MCS文件已生成: $output_file"')
        lines.append('} error_msg]} {')
        lines.append('    puts "错误: 生成MCS文件失败"')
        lines.append('    puts $error_msg')
        lines.append('}')
        lines.append('')

        # 如果需要，加载比特流到内存
        if self.load_bitstream:
            lines.append('# 加载比特流到内存')
            lines.append('if {[catch {')
            lines.append('    open_hw')
            lines.append('    connect_hw_server')
            lines.append('    open_hw_target')
            lines.append('    ')
            lines.append('    # 这里需要根据实际硬件设置')
            lines.append('    # set_property PROGRAM.FILE $bitstream_path [get_hw_devices]')
            lines.append('    # program_hw_devices [get_hw_devices]')
            lines.append('    ')
            lines.append('    puts "比特流已加载到内存"')
            lines.append('} error_msg]} {')
            lines.append('    puts "警告: 加载比特流到内存失败"')
            lines.append('    puts $error_msg')
            lines.append('}')
            lines.append('')

        lines.append('puts "MCS文件生成完成"')
        return '\n'.join(lines)